
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HoFF TXA Buffer Report</title>
  <style>
    :root {
      --bg: #ffffff;
      --fg: #111111;
      --muted: #666666;
      --card: #fafafa;
      --border: #dddddd;
      --accent: #1976d2;
    }
    .dark {
      --bg: #0f1216;
      --fg: #e7e9ee;
      --muted: #a0a9b6;
      --card: #161a21;
      --border: #2a3140;
      --accent: #4aa3ff;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 16px; background: var(--bg); color: var(--fg); }
    header { margin-bottom: 16px; }
    .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-bottom: 16px; }
    .card { border: 1px solid var(--border); border-radius: 8px; padding: 12px; background: var(--card); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin: 8px 0; }
    select, button { padding: 6px 10px; font-size: 14px; }
    #chart { border: 1px solid var(--border); background: var(--bg); border-radius: 8px; }
    .table-wrap { overflow: auto; border: 1px solid var(--border); border-radius: 8px; margin-top: 16px; }
    table { border-collapse: collapse; font-size: 12px; min-width: max(900px, 100%); }
    th, td { padding: 6px 8px; border: 1px solid var(--border); white-space: nowrap; background: var(--bg); color: var(--fg); }
    th { position: sticky; top: 0; background: color-mix(in oklab, var(--bg) 80%, var(--fg) 20%); z-index: 2; }
    .muted { color: var(--muted); }
    .toolbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .toolbar input[type="text"] { padding: 6px 10px; font-size: 14px; min-width: 220px; }
    .btn { background: var(--accent); color: #fff; border: none; border-radius: 6px; cursor: pointer; }
    .btn.secondary { background: transparent; color: var(--fg); border: 1px solid var(--border); }
    .stat { font-size: 13px; }
    .legend-wrap { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
    .sticky-col-1 { position: sticky; left: 0; z-index: 3; background: var(--bg); }
    .sticky-col-2 { position: sticky; left: 90px; z-index: 3; background: var(--bg); }
    .col-well { width: 90px; }
    .col-content { width: 180px; }
    .two-col { display: grid; grid-template-columns: 1.3fr 1fr; gap: 12px; align-items: start; }
  </style>
</head>
<body>
  <header>
    <h2>HoFF TXA Buffer Report</h2>
    <div class="summary">
      <div class="card"><b>Sheet</b><div id="sheetName"></div></div>
      <div class="card"><b>Channel</b><div id="channel"></div></div>
      <div class="card"><b>Wells</b><div id="numWells"></div></div>
      <div class="card"><b>Timepoints</b><div id="numTimes"></div></div>
    </div>
    <div class="card">
      <b>Metadata</b>
      <div id="meta" class="muted"></div>
    </div>
  </header>

  <section>
    <div class="row toolbar" role="group" aria-label="Controls">
      <div style="display:flex; align-items:center; gap:8px;">
        <label for="wellSelect"><b>Select well</b></label>
        <select id="wellSelect" aria-label="Select primary well"></select>
        <span class="muted" id="wellContent"></span>
      </div>
      <label for="multiWell" class="muted">Compare</label>
      <select id="multiWell" aria-label="Select comparison wells" multiple size="4" style="min-width:160px"></select>
      <label for="yScale" class="muted">Scale</label>
      <select id="yScale" aria-label="Y scale">
        <option value="linear">Linear</option>
        <option value="log">Log</option>
      </select>
      <label for="smoothChk" class="muted">Smooth</label>
      <input id="smoothChk" type="checkbox" aria-label="Smoothing" />
      <label for="normalize" class="muted">Normalize</label>
      <select id="normalize" aria-label="Normalization mode">
        <option value="none">None</option>
        <option value="t0">to t0</option>
        <option value="max">to max</option>
      </select>
      <button id="exportPng" class="btn secondary" title="Export chart as PNG" aria-label="Export chart as PNG">Export PNG</button>
      <input id="filterInput" type="text" placeholder="Filter wells by id or content..." />
      <label for="sortSelect" class="muted">Sort</label>
      <select id="sortSelect">
        <option value="none">None</option>
        <option value="peak">Peak desc</option>
        <option value="mean">Mean desc</option>
      </select>
      <button id="themeBtn" class="btn secondary" title="Toggle dark mode">Theme</button>
      <button id="dlWellBtn" class="btn" title="Download selected well CSV">Download well CSV</button>
      <button id="dlCorrBtn" class="btn secondary" title="Download correlation CSV">Correlation CSV</button>
      <button id="dlWideBtn" class="btn secondary" title="Download wide CSV">Wide CSV</button>
    </div>
    <div class="two-col">
      <svg id="chart" width="960" height="360"></svg>
      <div class="card">
        <b>Selected well stats</b>
        <div id="statsBox" class="stat muted"></div>
        <div id="legendBox" class="stat" style="margin-top:8px;"></div>
      </div>
    </div>
    <div id="tooltip" style="position:absolute; pointer-events:none; background: var(--card); color: var(--fg); border:1px solid var(--border); padding:6px 8px; border-radius:6px; font-size:12px; display:none;"></div>
  </section>

  <section id="relations" style="margin-top:16px;">
    <h3>Relations</h3>
    <div class="summary">
      <div class="card">
        <b>Correlation heatmap (Pearson r)</b>
        <div style="overflow:auto;">
          <canvas id="corrHeatmap" width="720" height="720" style="border:1px solid var(--border); border-radius:8px;"></canvas>
        </div>
        <div class="legend-wrap">
          <canvas id="legend" width="240" height="16" style="border:1px solid var(--border);"></canvas>
          <span class="muted">-1</span><span class="muted" style="margin-left:auto">+1</span>
        </div>
        <div class="muted" style="margin-top:6px;">
          Blue = negative, White = 0, Red = positive; click a cell to select that well (row).
        </div>
        <div class="row" style="margin-top:8px; gap:12px;">
          <label class="muted">Window</label>
          <input id="winStart" type="range" min="0" max="59" value="0" />
          <input id="winEnd" type="range" min="0" max="59" value="59" />
          <span id="winLabel" class="muted"></span>
          <button id="clusterBtn" class="btn secondary">Cluster order</button>
          <button id="resetOrderBtn" class="btn secondary">Reset order</button>
        </div>
      </div>
      <div class="card">
        <b>Most similar wells</b>
        <div id="neighborsList" class="muted"></div>
      </div>
      <div class="card">
        <b>Top correlated pairs</b>
        <table id="topPairsTable" style="width:100%">
          <thead><tr><th>Well A</th><th>Well B</th><th>r</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>

  <section class="table-wrap">
    <div class="row" style="padding:8px;">
      <span class="muted">Content chips:</span>
      <div id="chips" class="row" style="gap:6px;"></div>
      <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
        <label class="muted">Page size</label>
        <select id="pageSize">
          <option>10</option>
          <option>20</option>
          <option selected>50</option>
          <option>100</option>
        </select>
        <button id="prevPage" class="btn secondary">Prev</button>
        <span id="pageInfo" class="muted"></span>
        <button id="nextPage" class="btn secondary">Next</button>
      </div>
    </div>
    <table id="dataTable"></table>
  </section>

  <script>
    const DATA = {"metadata": {"User": "Medcalf2", "Path": "C:\\Program Files (x86)\\BMG\\CLARIOstar\\Medcalf2\\Data", "Test ID": "32", "Test Name": "HoFF 647 60m", "Date": "17/06/2025", "Time": "12:11:48 PM", "Info": ["Fluorescence (FI)", "Well"]}, "sheet": "Table All Cycles", "channel": "Raw Data (625-30/680-30)", "timeLabels": ["0 min", "1 min", "2 min", "3 min", "4 min", "5 min", "6 min", "7 min", "8 min", "9 min", "10 min", "11 min", "12 min", "13 min", "14 min", "15 min", "16 min", "17 min", "18 min", "19 min", "20 min", "21 min", "22 min", "23 min", "24 min", "25 min", "26 min", "27 min", "28 min", "29 min", "30 min", "31 min", "32 min", "33 min", "34 min", "35 min", "36 min", "37 min", "38 min", "39 min", "40 min", "41 min", "42 min", "43 min", "44 min", "45 min", "46 min", "47 min", "48 min", "49 min", "50 min", "51 min", "52 min", "53 min", "54 min", "55 min", "56 min", "57 min", "58 min", "59 min"], "wells": [{"well": "A01", "content": "Sample X1", "values": [698.0, 1044.0, 1309.0, 1755.0, 2890.0, 6420.0, 12941.0, 19397.0, 23834.0, 26016.0, 28400.0, 30299.0, 33323.0, 35017.0, 36715.0, 38635.0, 39110.0, 40967.0, 43187.0, 43963.0, 44686.0, 45331.0, 46278.0, 47295.0, 47520.0, 47682.0, 48579.0, 48515.0, 48368.0, 48548.0, 49421.0, 48797.0, 48770.0, 48379.0, 48563.0, 48168.0, 48609.0, 48468.0, 48925.0, 48570.0, 48515.0, 48825.0, 49117.0, 48551.0, 48932.0, 48361.0, 48386.0, 48446.0, 48343.0, 48565.0, 48603.0, 49232.0, 48808.0, 48473.0, 48696.0, 48336.0, 47822.0, 47816.0, 47298.0, 47963.0]}, {"well": "A02", "content": "Sample X2", "values": [747.0, 1151.0, 1544.0, 2171.0, 3230.0, 5519.0, 9314.0, 13433.0, 17932.0, 21981.0, 25816.0, 29558.0, 32075.0, 34919.0, 37129.0, 38908.0, 40305.0, 41422.0, 42721.0, 44179.0, 44974.0, 46777.0, 46721.0, 47968.0, 49086.0, 49471.0, 49655.0, 49974.0, 50867.0, 50850.0, 51229.0, 52172.0, 51611.0, 52597.0, 52856.0, 53320.0, 54303.0, 53273.0, 53752.0, 54190.0, 54431.0, 54040.0, 53765.0, 54164.0, 53508.0, 53093.0, 53725.0, 53729.0, 53341.0, 53673.0, 52587.0, 53274.0, 52991.0, 52544.0, 52572.0, 52958.0, 52255.0, 52029.0, 52583.0, 52017.0]}, {"well": "A05", "content": "Sample X17", "values": [990.0, 1348.0, 1418.0, 1666.0, 1746.0, 1721.0, 1767.0, 1894.0, 2007.0, 2050.0, 2011.0, 2036.0, 2264.0, 2129.0, 2090.0, 2119.0, 2148.0, 2255.0, 2282.0, 2237.0, 2238.0, 2268.0, 2283.0, 2450.0, 2377.0, 2257.0, 2292.0, 2270.0, 2284.0, 2252.0, 2336.0, 2332.0, 2231.0, 2208.0, 2313.0, 2404.0, 2354.0, 2306.0, 2442.0, 2127.0, 2276.0, 2296.0, 2228.0, 2295.0, 2358.0, 2235.0, 2217.0, 2291.0, 2242.0, 2120.0, 2175.0, 2103.0, 2172.0, 2128.0, 2176.0, 2110.0, 2213.0, 2204.0, 2263.0, 2235.0]}, {"well": "A06", "content": "Sample X18", "values": [1002.0, 1147.0, 1471.0, 1634.0, 1748.0, 1747.0, 1906.0, 1930.0, 2058.0, 2003.0, 2019.0, 2197.0, 2228.0, 2297.0, 2319.0, 2240.0, 2173.0, 2422.0, 2353.0, 2256.0, 2190.0, 2319.0, 2341.0, 2499.0, 2399.0, 2401.0, 2398.0, 2356.0, 2284.0, 2435.0, 2326.0, 2220.0, 2349.0, 2367.0, 2383.0, 2363.0, 2449.0, 2388.0, 2497.0, 2408.0, 2445.0, 2395.0, 2507.0, 2383.0, 2366.0, 2376.0, 2391.0, 2386.0, 2378.0, 2412.0, 2328.0, 2351.0, 2359.0, 2369.0, 2535.0, 2275.0, 2335.0, 2430.0, 2342.0, 2371.0]}, {"well": "B01", "content": "Sample X3", "values": [825.0, 1211.0, 1455.0, 1755.0, 1784.0, 1967.0, 2300.0, 2668.0, 3691.0, 5476.0, 9203.0, 12992.0, 16830.0, 19593.0, 22675.0, 25677.0, 27798.0, 29238.0, 31146.0, 32451.0, 33311.0, 35300.0, 35809.0, 37168.0, 38329.0, 37701.0, 38630.0, 39461.0, 40461.0, 41305.0, 41288.0, 42291.0, 42603.0, 43153.0, 43661.0, 44419.0, 44491.0, 44821.0, 45794.0, 45999.0, 46607.0, 46563.0, 47280.0, 47312.0, 48043.0, 48059.0, 47943.0, 48517.0, 49081.0, 49145.0, 49620.0, 48596.0, 49584.0, 49888.0, 49552.0, 50119.0, 50056.0, 49320.0, 49490.0, 49413.0]}, {"well": "B02", "content": "Sample X4", "values": [792.0, 1040.0, 1361.0, 1486.0, 1618.0, 1836.0, 1867.0, 2305.0, 2645.0, 3483.0, 5211.0, 7035.0, 9270.0, 11034.0, 13555.0, 16604.0, 18906.0, 22130.0, 24713.0, 27299.0, 30518.0, 32277.0, 34318.0, 35253.0, 37149.0, 36891.0, 38350.0, 39085.0, 39514.0, 39987.0, 40831.0, 41179.0, 41981.0, 42526.0, 42889.0, 43275.0, 43235.0, 43881.0, 44772.0, 45170.0, 45145.0, 45628.0, 45976.0, 46066.0, 46651.0, 46204.0, 47277.0, 46785.0, 47636.0, 47931.0, 47945.0, 48392.0, 48063.0, 47540.0, 48004.0, 48500.0, 48499.0, 48566.0, 49292.0, 48911.0]}, {"well": "B05", "content": "Sample X19", "values": [38958.0, 39389.0, 38510.0, 38355.0, 38690.0, 37960.0, 38157.0, 38172.0, 37640.0, 37602.0, 37822.0, 37437.0, 37720.0, 36970.0, 37536.0, 37275.0, 37406.0, 37380.0, 37077.0, 37258.0, 37179.0, 36739.0, 36720.0, 36801.0, 37013.0, 36486.0, 36911.0, 37098.0, 36908.0, 37193.0, 36172.0, 37170.0, 36058.0, 36977.0, 36267.0, 36700.0, 36697.0, 37147.0, 36096.0, 36316.0, 36128.0, 36709.0, 36548.0, 36420.0, 36148.0, 35867.0, 35930.0, 36104.0, 35847.0, 36366.0, 35828.0, 35477.0, 36134.0, 35715.0, 35595.0, 35605.0, 35235.0, 34908.0, 35844.0, 35990.0]}, {"well": "B06", "content": "Sample X20", "values": [38777.0, 38464.0, 38137.0, 38226.0, 37822.0, 38024.0, 37416.0, 37261.0, 37108.0, 37170.0, 37189.0, 36695.0, 36819.0, 37332.0, 37303.0, 36578.0, 36925.0, 36938.0, 35985.0, 36807.0, 36825.0, 36902.0, 36487.0, 36117.0, 36797.0, 36087.0, 35849.0, 36116.0, 36116.0, 36026.0, 35682.0, 35626.0, 36065.0, 35629.0, 35640.0, 35900.0, 35973.0, 35767.0, 35411.0, 35835.0, 35285.0, 35461.0, 35361.0, 35930.0, 35320.0, 35078.0, 34981.0, 34889.0, 35316.0, 35157.0, 34800.0, 35040.0, 34658.0, 34511.0, 34598.0, 35101.0, 34495.0, 34865.0, 34621.0, 33904.0]}, {"well": "C01", "content": "Sample X5", "values": [899.0, 1062.0, 1347.0, 1455.0, 1594.0, 1654.0, 1858.0, 1986.0, 2006.0, 2581.0, 3485.0, 4864.0, 6987.0, 9293.0, 11433.0, 13643.0, 16380.0, 18969.0, 21457.0, 23705.0, 25432.0, 26468.0, 27522.0, 28335.0, 29356.0, 30136.0, 31062.0, 31127.0, 32117.0, 33030.0, 33845.0, 34484.0, 34814.0, 35619.0, 35343.0, 35940.0, 37106.0, 36856.0, 38091.0, 37907.0, 38086.0, 38222.0, 39044.0, 39414.0, 39301.0, 40254.0, 40371.0, 40355.0, 40785.0, 40784.0, 41025.0, 40602.0, 41138.0, 41094.0, 41397.0, 41575.0, 41414.0, 41787.0, 42162.0, 42442.0]}, {"well": "C02", "content": "Sample X6", "values": [960.0, 1168.0, 1384.0, 1509.0, 1551.0, 1642.0, 1709.0, 1916.0, 2137.0, 2513.0, 2916.0, 3780.0, 4851.0, 6427.0, 8864.0, 12498.0, 16132.0, 19072.0, 21415.0, 23459.0, 24708.0, 24730.0, 25596.0, 27068.0, 27660.0, 28321.0, 29618.0, 30305.0, 31046.0, 31866.0, 32718.0, 33175.0, 33358.0, 33985.0, 34258.0, 34815.0, 35177.0, 35380.0, 36371.0, 36721.0, 36407.0, 37521.0, 37324.0, 38527.0, 38626.0, 38676.0, 39306.0, 38900.0, 39501.0, 40232.0, 40376.0, 40006.0, 39460.0, 40102.0, 40741.0, 40973.0, 41066.0, 41452.0, 41352.0, 41719.0]}, {"well": "D01", "content": "Sample X7", "values": [779.0, 1056.0, 1326.0, 1525.0, 1600.0, 1853.0, 1966.0, 1999.0, 2283.0, 2566.0, 3112.0, 3971.0, 4767.0, 6255.0, 7477.0, 9880.0, 12468.0, 15061.0, 17369.0, 18948.0, 20133.0, 19919.0, 19996.0, 21794.0, 22698.0, 22453.0, 23021.0, 23576.0, 24294.0, 24399.0, 25359.0, 25815.0, 26363.0, 26290.0, 28025.0, 28014.0, 28394.0, 28944.0, 29920.0, 29959.0, 30524.0, 30697.0, 30972.0, 31264.0, 31365.0, 32016.0, 32391.0, 32496.0, 33018.0, 33060.0, 33427.0, 33576.0, 33699.0, 33621.0, 33905.0, 34494.0, 34189.0, 34569.0, 34867.0, 34827.0]}, {"well": "D02", "content": "Sample X8", "values": [805.0, 1031.0, 1180.0, 1362.0, 1488.0, 1593.0, 1825.0, 1912.0, 2190.0, 2410.0, 2862.0, 3490.0, 4210.0, 4870.0, 6305.0, 7498.0, 8944.0, 10973.0, 13227.0, 15852.0, 17806.0, 19163.0, 19744.0, 21059.0, 22004.0, 22364.0, 22873.0, 23883.0, 24127.0, 25452.0, 25448.0, 26124.0, 26815.0, 26996.0, 27477.0, 28132.0, 28356.0, 29161.0, 29620.0, 29420.0, 30262.0, 29998.0, 30640.0, 30744.0, 31236.0, 31704.0, 31659.0, 32285.0, 32209.0, 32591.0, 32718.0, 33115.0, 33061.0, 32907.0, 33276.0, 33719.0, 34094.0, 34357.0, 34389.0, 34171.0]}, {"well": "E01", "content": "Sample X9", "values": [1076.0, 1266.0, 1550.0, 1544.0, 1667.0, 1715.0, 1864.0, 1961.0, 2121.0, 2222.0, 2349.0, 2594.0, 2948.0, 3470.0, 3690.0, 4034.0, 5388.0, 6885.0, 8377.0, 8839.0, 9895.0, 11384.0, 12587.0, 13481.0, 14345.0, 14828.0, 15645.0, 16479.0, 16544.0, 17551.0, 18033.0, 19020.0, 19230.0, 19519.0, 20227.0, 20749.0, 20667.0, 21261.0, 21835.0, 22317.0, 22313.0, 22652.0, 23482.0, 23419.0, 23294.0, 23934.0, 23906.0, 24165.0, 24253.0, 24523.0, 24441.0, 24703.0, 24924.0, 24868.0, 25454.0, 25380.0, 24839.0, 25589.0, 24920.0, 25476.0]}, {"well": "E02", "content": "Sample X10", "values": [1009.0, 1172.0, 1450.0, 1638.0, 1664.0, 1774.0, 1876.0, 2027.0, 2144.0, 2302.0, 2515.0, 2846.0, 3130.0, 3692.0, 3886.0, 4608.0, 5184.0, 6402.0, 8273.0, 9251.0, 10817.0, 12741.0, 14003.0, 14560.0, 17098.0, 18388.0, 19612.0, 20818.0, 20925.0, 21275.0, 21554.0, 21317.0, 21973.0, 22182.0, 22341.0, 21926.0, 22716.0, 22443.0, 23104.0, 23071.0, 23269.0, 23568.0, 24126.0, 24025.0, 24474.0, 24586.0, 25074.0, 24588.0, 25047.0, 25236.0, 24870.0, 25286.0, 25415.0, 25272.0, 25689.0, 25722.0, 25898.0, 25821.0, 26323.0, 26355.0]}, {"well": "F01", "content": "Sample X11", "values": [966.0, 1284.0, 1454.0, 1510.0, 1631.0, 1692.0, 1686.0, 1931.0, 2208.0, 2152.0, 2309.0, 2477.0, 2585.0, 3088.0, 3072.0, 3328.0, 3574.0, 3855.0, 4130.0, 4224.0, 4260.0, 4598.0, 4862.0, 4877.0, 5766.0, 6158.0, 6749.0, 7477.0, 8227.0, 8694.0, 9187.0, 9881.0, 10429.0, 10362.0, 10695.0, 11104.0, 11265.0, 11516.0, 11806.0, 11482.0, 11780.0, 12635.0, 12350.0, 12643.0, 12497.0, 12933.0, 13082.0, 13018.0, 13136.0, 13402.0, 13588.0, 13403.0, 13724.0, 13944.0, 14056.0, 14202.0, 14467.0, 14056.0, 14640.0, 14573.0]}, {"well": "F02", "content": "Sample X12", "values": [905.0, 1211.0, 1409.0, 1545.0, 1629.0, 1752.0, 1750.0, 1793.0, 1977.0, 2192.0, 2259.0, 2441.0, 2835.0, 2861.0, 3032.0, 3534.0, 3665.0, 3814.0, 4034.0, 4428.0, 4724.0, 5086.0, 5690.0, 6643.0, 8243.0, 9343.0, 9921.0, 10350.0, 10932.0, 10761.0, 10847.0, 10911.0, 11031.0, 11922.0, 11914.0, 12138.0, 12667.0, 13016.0, 13506.0, 12914.0, 13264.0, 12948.0, 13176.0, 13451.0, 13496.0, 13868.0, 13701.0, 14331.0, 14246.0, 14021.0, 14041.0, 14267.0, 14325.0, 14551.0, 14499.0, 14905.0, 14656.0, 14628.0, 15090.0, 14707.0]}, {"well": "G01", "content": "Sample X13", "values": [936.0, 1173.0, 1370.0, 1510.0, 1695.0, 1865.0, 2019.0, 2064.0, 2029.0, 2180.0, 2548.0, 2531.0, 2771.0, 3080.0, 3120.0, 3338.0, 3593.0, 3759.0, 3940.0, 4112.0, 4146.0, 4388.0, 4510.0, 4920.0, 4870.0, 4775.0, 5098.0, 5183.0, 5422.0, 5158.0, 5430.0, 5464.0, 5667.0, 5705.0, 5797.0, 5580.0, 5756.0, 5804.0, 5888.0, 6098.0, 6361.0, 6150.0, 6215.0, 6494.0, 6703.0, 6757.0, 6658.0, 7227.0, 6936.0, 7282.0, 7234.0, 7392.0, 7683.0, 7510.0, 7803.0, 7861.0, 7807.0, 7911.0, 8322.0, 8226.0]}, {"well": "G02", "content": "Sample X14", "values": [983.0, 1175.0, 1576.0, 1517.0, 1669.0, 1744.0, 1981.0, 2035.0, 2310.0, 2344.0, 2612.0, 2748.0, 2892.0, 2953.0, 3149.0, 3465.0, 3527.0, 3555.0, 3642.0, 4015.0, 4006.0, 4188.0, 4268.0, 4350.0, 4586.0, 4651.0, 4688.0, 4717.0, 4801.0, 4862.0, 4961.0, 4989.0, 5090.0, 5145.0, 5215.0, 5323.0, 5383.0, 5518.0, 5519.0, 5787.0, 5581.0, 6130.0, 5954.0, 6169.0, 6429.0, 6187.0, 6495.0, 6580.0, 6638.0, 7102.0, 6801.0, 6912.0, 7200.0, 7279.0, 7413.0, 7068.0, 7436.0, 7528.0, 7544.0, 7701.0]}, {"well": "H01", "content": "Sample X15", "values": [954.0, 1337.0, 1470.0, 1719.0, 1695.0, 1833.0, 1962.0, 2113.0, 2161.0, 2424.0, 2414.0, 2675.0, 2675.0, 2947.0, 3140.0, 3244.0, 3428.0, 3447.0, 3704.0, 3919.0, 4029.0, 4044.0, 4195.0, 4099.0, 4201.0, 4244.0, 4510.0, 4610.0, 4658.0, 4645.0, 4558.0, 4760.0, 4688.0, 4757.0, 4693.0, 4792.0, 4810.0, 4891.0, 4929.0, 4874.0, 4717.0, 4793.0, 4899.0, 4732.0, 4624.0, 4828.0, 4851.0, 4923.0, 5055.0, 4911.0, 5101.0, 5240.0, 5140.0, 5083.0, 5205.0, 5442.0, 5428.0, 5531.0, 5342.0, 5485.0]}, {"well": "H02", "content": "Sample X16", "values": [896.0, 1285.0, 1559.0, 1548.0, 1830.0, 2096.0, 2139.0, 2275.0, 2397.0, 2762.0, 3032.0, 3287.0, 3489.0, 3553.0, 3698.0, 3759.0, 4020.0, 3822.0, 3832.0, 4094.0, 4319.0, 4273.0, 4410.0, 4619.0, 4776.0, 4704.0, 4926.0, 4869.0, 5071.0, 4984.0, 5046.0, 5109.0, 4807.0, 5264.0, 5010.0, 5279.0, 5252.0, 5287.0, 5293.0, 5351.0, 5480.0, 5428.0, 5562.0, 5489.0, 5564.0, 5693.0, 5666.0, 5687.0, 5963.0, 5963.0, 5799.0, 6040.0, 5954.0, 6061.0, 6109.0, 5870.0, 6197.0, 6282.0, 6115.0, 6267.0]}], "yMin": 698.0, "yMax": 54431.0};

    // Populate summary
    document.getElementById('sheetName').textContent = DATA.sheet;
    document.getElementById('channel').textContent = DATA.channel;
    document.getElementById('numWells').textContent = DATA.wells.length;
    document.getElementById('numTimes').textContent = DATA.timeLabels.length;

    // Metadata
    const metaDiv = document.getElementById('meta');
    const md = DATA.metadata || {};
    const lines = [];
    for (const k of Object.keys(md)) {
      const v = md[k];
      if (Array.isArray(v)) {
        for (const item of v) lines.push(item);
      } else {
        lines.push(`${k}: ${v}`);
      }
    }
    metaDiv.textContent = lines.join('  |  ');

    // Build well selector
    const wellSelect = document.getElementById('wellSelect');
    for (const w of DATA.wells) {
      const opt = document.createElement('option');
      opt.value = w.well; opt.textContent = w.well; wellSelect.appendChild(opt);
    }
    const multiWell = document.getElementById('multiWell');
    for (const w of DATA.wells) {
      const opt = document.createElement('option'); opt.value = w.well; opt.textContent = w.well; multiWell.appendChild(opt);
    }

    const wellContent = document.getElementById('wellContent');
    const svg = document.getElementById('chart');

    // Helper: settings with persistence
    const yScaleSel = document.getElementById('yScale');
    const smoothChk = document.getElementById('smoothChk');
    const normalizeSel = document.getElementById('normalize');
    const exportBtn = document.getElementById('exportPng');
    const legendBox = document.getElementById('legendBox');
    const tooltip = document.getElementById('tooltip');

    // Load settings
    try {
      const saved = JSON.parse(localStorage.getItem('hoff-settings') || '{}');
      if (saved.yScale) yScaleSel.value = saved.yScale;
      if (saved.smooth) smoothChk.checked = !!saved.smooth;
      if (saved.normalize) normalizeSel.value = saved.normalize;
      if (Array.isArray(saved.multi)) {
        for (const id of saved.multi) { const opt = Array.from(multiWell.options).find(o=>o.value===id); if (opt) opt.selected = true; }
      }
    } catch {}

    function saveSettings() {
      const multi = Array.from(multiWell.selectedOptions).map(o=>o.value);
      localStorage.setItem('hoff-settings', JSON.stringify({ yScale: yScaleSel.value, smooth: smoothChk.checked, normalize: normalizeSel.value, multi }));
    }

    function palette(idx) {
      const colors = ['#1976d2','#d32f2f','#388e3c','#7b1fa2','#f9a825','#00796b','#5d4037','#c2185b','#0288d1','#512da8'];
      return colors[idx % colors.length];
    }

    function movingAverage(arr, win=3) {
      if (win<=1) return arr.slice();
      const half = Math.floor(win/2); const out = Array(arr.length).fill(null);
      for (let i=0;i<arr.length;i++){
        let s=0,c=0; for(let k=-half;k<=half;k++){ const j=i+k; const v=arr[j]; if(j>=0 && j<arr.length && v!=null && isFinite(v)){ s+=v; c++; } }
        out[i]= c? s/c : null;
      }
      return out;
    }

    function normalize(values, mode) {
      const arr = values.slice();
      if (mode==='none') return arr;
      const valid = arr.filter(v=>v!=null && isFinite(v));
      if (!valid.length) return arr;
      if (mode==='t0') {
        const base = arr.find(v=>v!=null && isFinite(v));
        if (!base) return arr; return arr.map(v=> v==null? null : v/base);
      }
      if (mode==='max') {
        const mx = Math.max(...valid);
        return arr.map(v=> v==null? null : v/mx);
      }
      return arr;
    }

    function transform(values) {
      let v = values.slice();
      v = normalize(v, normalizeSel.value);
      if (smoothChk.checked) v = movingAverage(v, 3);
      return v;
    }

    function getSelectedIds() {
      const ids = Array.from(multiWell.selectedOptions).map(o=>o.value);
      if (ids.length) return ids;
      return [wellSelect.value || (DATA.wells[0] && DATA.wells[0].well)];
    }

    function renderChart() {
      const ids = getSelectedIds();
      const series = ids.map(id => {
        const w = DATA.wells.find(x=>x.well===id);
        return { id, content: w? w.content: '', values: w? transform(w.values): [] };
      });
      wellContent.textContent = (ids.length===1 && series[0]) ? (series[0].content? `Content: ${series[0].content}` : '') : `${ids.length} wells`;
      const width = svg.viewBox.baseVal && svg.viewBox.baseVal.width ? svg.viewBox.baseVal.width : svg.getAttribute('width');
      const height = svg.viewBox.baseVal && svg.viewBox.baseVal.height ? svg.viewBox.baseVal.height : svg.getAttribute('height');
      const W = +width, H = +height;

      while (svg.firstChild) svg.removeChild(svg.firstChild);

      const pad = { left: 50, right: 20, top: 20, bottom: 40 };
      const innerW = W - pad.left - pad.right;
      const innerH = H - pad.top - pad.bottom;
      const n = DATA.timeLabels.length;
      const x = i => pad.left + (i/(Math.max(1,n-1))) * innerW;

      // Y domain from transformed data
      let all = [];
      for (const s of series) all.push(...s.values.filter(v=>v!=null && isFinite(v)));
      let ymin = all.length? Math.min(...all): 0; let ymax = all.length? Math.max(...all): 1;
      if (yScaleSel.value==='log') { ymin = Math.max(1e-6, ymin); }
      const yLin = v => pad.top + innerH - ( (v - ymin) / (Math.max(1e-12, ymax - ymin)) ) * innerH;
      const yLog = v => pad.top + innerH - ( (Math.log(Math.max(v,1e-6)) - Math.log(ymin)) / Math.max(1e-12, Math.log(ymax)-Math.log(ymin)) ) * innerH;
      const y = (v) => yScaleSel.value==='log'? yLog(v): yLin(v);

      const axis = document.createElementNS('http://www.w3.org/2000/svg','path');
      axis.setAttribute('d', `M${pad.left},${pad.top} v${innerH} h${innerW}`);
      axis.setAttribute('stroke', '#aaa'); axis.setAttribute('fill', 'none'); axis.setAttribute('stroke-width', '1'); svg.appendChild(axis);
      // axis labels
      const yLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
      yLabel.setAttribute('transform', `translate(${pad.left-40},${pad.top+innerH/2}) rotate(-90)`);
      yLabel.setAttribute('text-anchor', 'middle'); yLabel.setAttribute('font-size','12'); yLabel.textContent = 'Fluorescence (a.u.)'; svg.appendChild(yLabel);
      const xLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
      xLabel.setAttribute('x', pad.left + innerW/2); xLabel.setAttribute('y', pad.top + innerH + 34);
      xLabel.setAttribute('text-anchor','middle'); xLabel.setAttribute('font-size','12'); xLabel.textContent = 'Time (min)'; svg.appendChild(xLabel);

      for (let i=0; i<=5; i++) {
        const tv = yScaleSel.value==='log' ? (ymin * Math.pow(ymax/ymin, i/5)) : (ymin + (i/5)*(ymax - ymin));
        const ty = y(tv);
        const grid = document.createElementNS('http://www.w3.org/2000/svg','line'); grid.setAttribute('x1', pad.left); grid.setAttribute('x2', pad.left + innerW); grid.setAttribute('y1', ty); grid.setAttribute('y2', ty); grid.setAttribute('stroke', '#eee'); svg.appendChild(grid);
        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text'); lbl.setAttribute('x', pad.left - 6); lbl.setAttribute('y', ty + 4); lbl.setAttribute('text-anchor', 'end'); lbl.setAttribute('font-size', '11'); lbl.textContent = (yScaleSel.value==='log'? tv.toExponential(1) : tv.toFixed(0)); svg.appendChild(lbl);
      }
      for (let i=0; i<n; i+=10) {
        const tx = x(i);
        const lbl = document.createElementNS('http://www.w3.org/2000/svg','text'); lbl.setAttribute('x', tx); lbl.setAttribute('y', pad.top + innerH + 20); lbl.setAttribute('text-anchor', 'middle'); lbl.setAttribute('font-size', '11'); lbl.textContent = DATA.timeLabels[i]; svg.appendChild(lbl);
      }

      // Draw lines
      series.forEach((s, si) => {
        let d='';
        for (let i=0;i<n;i++) { const v = s.values[i]; if (v==null || !isFinite(v)) continue; const px=x(i), py=y(v); d += (d? ' L':'M')+px+','+py; }
        const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.setAttribute('d', d); path.setAttribute('fill','none'); path.setAttribute('stroke', palette(si)); path.setAttribute('stroke-width','2'); svg.appendChild(path);
      });

      // Legend
      legendBox.innerHTML = series.map((s,si)=>`<span style="display:inline-flex;align-items:center;gap:6px;margin-right:8px"><span style="display:inline-block;width:12px;height:12px;background:${palette(si)};"></span>${s.id}</span>`).join('');

      // Tooltip overlay
      const overlay = document.createElementNS('http://www.w3.org/2000/svg','rect'); overlay.setAttribute('x', pad.left); overlay.setAttribute('y', pad.top); overlay.setAttribute('width', innerW); overlay.setAttribute('height', innerH); overlay.setAttribute('fill','transparent'); svg.appendChild(overlay);
      const vline = document.createElementNS('http://www.w3.org/2000/svg','line'); vline.setAttribute('stroke','#999'); vline.setAttribute('y1', pad.top); vline.setAttribute('y2', pad.top+innerH); vline.setAttribute('visibility','hidden'); svg.appendChild(vline);
      overlay.addEventListener('mousemove', (ev)=>{
        const rect = svg.getBoundingClientRect(); const mx = ev.clientX - rect.left; const t = Math.max(0, Math.min(n-1, Math.round((mx - pad.left)/innerW*(n-1))));
        const tx = x(t); vline.setAttribute('x1', tx); vline.setAttribute('x2', tx); vline.setAttribute('visibility','visible');
        const rows = series.map((s,si)=>({ id:s.id, color:palette(si), v:s.values[t] }));
        const html = `<div><b>${DATA.timeLabels[t]}</b></div>` + rows.map(r=>`<div><span style="display:inline-block;width:10px;height:10px;background:${r.color};margin-right:6px"></span>${r.id}: ${r.v==null? '' : (yScaleSel.value==='log'? r.v.toExponential(2): r.v.toFixed(0))}</div>`).join('');
        tooltip.innerHTML = html; tooltip.style.display='block'; tooltip.style.left = (rect.left + tx + 12) + 'px'; tooltip.style.top = (rect.top + pad.top + 8) + 'px';
      });
      overlay.addEventListener('mouseleave', ()=>{ vline.setAttribute('visibility','hidden'); tooltip.style.display='none'; });

      // Export
      exportBtn.onclick = ()=>{
        const serializer = new XMLSerializer(); const svgStr = serializer.serializeToString(svg); const img = new Image(); const canvas = document.createElement('canvas'); canvas.width = W; canvas.height = H; const ctx = canvas.getContext('2d');
        img.onload = ()=>{ ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg').trim() || '#fff'; ctx.fillRect(0,0,W,H); ctx.drawImage(img,0,0); const a = document.createElement('a'); a.download = 'chart.png'; a.href = canvas.toDataURL('image/png'); a.click(); };
        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);
      };
    }

    function refreshChartAndSave(){ renderChart(); renderStats(getSelectedIds()[0]); saveSettings(); }
    wellSelect.addEventListener('change', refreshChartAndSave);
    multiWell.addEventListener('change', refreshChartAndSave);
    yScaleSel.addEventListener('change', refreshChartAndSave);
    smoothChk.addEventListener('change', refreshChartAndSave);
    normalizeSel.addEventListener('change', refreshChartAndSave);
    if (DATA.wells.length) {
      wellSelect.value = DATA.wells[0].well;
      renderChart(DATA.wells[0].well);
    }

    // Build wide table with sticky first columns
    const table = document.getElementById('dataTable');
    function renderTable(rows) {
      table.innerHTML = '';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      const thWell = document.createElement('th'); thWell.textContent = 'Well'; thWell.className = 'sticky-col-1 col-well'; trh.appendChild(thWell);
      const thContent = document.createElement('th'); thContent.textContent = 'Content'; thContent.className = 'sticky-col-2 col-content'; trh.appendChild(thContent);
      for (const t of DATA.timeLabels) { const th = document.createElement('th'); th.textContent = t; trh.appendChild(th); }
      thead.appendChild(trh); table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (const w of rows) {
        const tr = document.createElement('tr');
        const tdW = document.createElement('td'); tdW.textContent = w.well; tdW.className = 'sticky-col-1'; tr.appendChild(tdW);
        const tdC = document.createElement('td'); tdC.textContent = w.content || ''; tdC.className = 'sticky-col-2'; tr.appendChild(tdC);
        for (const v of w.values) { const td = document.createElement('td'); td.textContent = (v==null? '' : v); tr.appendChild(td); }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
    }
    // Table features
    let currentRows = DATA.wells.slice();
    let currentPage = 1; const pageSizeSel = document.getElementById('pageSize'); const pageInfo = document.getElementById('pageInfo');
    function renderTable(rows) {
      currentRows = rows.slice(); const pageSize = parseInt(pageSizeSel.value,10); const total = currentRows.length; const pages = Math.max(1, Math.ceil(total/pageSize)); if (currentPage>pages) currentPage=pages; const start=(currentPage-1)*pageSize; const end=Math.min(total, start+pageSize); const pageRows = currentRows.slice(start,end);
      table.innerHTML = '';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      const thWell = document.createElement('th'); thWell.textContent = 'Well'; thWell.className = 'sticky-col-1 col-well'; thWell.dataset.key='well'; trh.appendChild(thWell);
      const thContent = document.createElement('th'); thContent.textContent = 'Content'; thContent.className = 'sticky-col-2 col-content'; thContent.dataset.key='content'; trh.appendChild(thContent);
      const thTrend = document.createElement('th'); thTrend.textContent = 'Trend'; trh.appendChild(thTrend);
      for (let ci=0; ci<DATA.timeLabels.length; ci++) { const t = DATA.timeLabels[ci]; const th = document.createElement('th'); th.textContent = t; th.dataset.key='c'+ci; trh.appendChild(th); }
      thead.appendChild(trh); table.appendChild(thead);

      // per-column min/max for formatting
      const colMin = Array(DATA.timeLabels.length).fill(+Infinity); const colMax = Array(DATA.timeLabels.length).fill(-Infinity);
      for (const w of pageRows) { for (let i=0;i<DATA.timeLabels.length;i++){ const v=w.values[i]; if (v!=null && isFinite(v)) { if (v<colMin[i]) colMin[i]=v; if (v>colMax[i]) colMax[i]=v; } } }

      const tbody = document.createElement('tbody');
      for (const w of pageRows) {
        const tr = document.createElement('tr');
        const tdW = document.createElement('td'); tdW.textContent = w.well; tdW.className = 'sticky-col-1'; tr.appendChild(tdW);
        const tdC = document.createElement('td'); tdC.textContent = w.content || ''; tdC.className = 'sticky-col-2'; tr.appendChild(tdC);
        // sparkline
        const tdS = document.createElement('td'); const sW=120,sH=24,pad=2; const svgS = document.createElementNS('http://www.w3.org/2000/svg','svg'); svgS.setAttribute('width', sW); svgS.setAttribute('height', sH);
        const vals = w.values.filter(v=>v!=null && isFinite(v)); const mn=vals.length?Math.min(...vals):0; const mx=vals.length?Math.max(...vals):1; const xS=(i)=>pad + i/(DATA.timeLabels.length-1)*(sW-2*pad); const yS=(v)=> pad + (sH-2*pad) - ( (v-mn)/Math.max(1e-12,(mx-mn)) )*(sH-2*pad);
        let d=''; for(let i=0;i<DATA.timeLabels.length;i++){ const v=w.values[i]; if(v==null||!isFinite(v)) continue; const px=xS(i), py=yS(v); d+=(d? ' L':'M')+px+','+py; } const pth=document.createElementNS('http://www.w3.org/2000/svg','path'); pth.setAttribute('d', d); pth.setAttribute('fill','none'); pth.setAttribute('stroke','#888'); pth.setAttribute('stroke-width','1'); svgS.appendChild(pth); tdS.appendChild(svgS); tr.appendChild(tdS);
        for (let i=0;i<DATA.timeLabels.length;i++) { const v=w.values[i]; const td=document.createElement('td'); td.textContent = (v==null? '' : v); if (v!=null && isFinite(v) && isFinite(colMin[i]) && isFinite(colMax[i]) && colMax[i]>colMin[i]) { const t=(v-colMin[i])/(colMax[i]-colMin[i]); const R=255, G=Math.round(255*(1-t)), B=Math.round(200*(1-t)); td.style.background = `rgb(${R},${G},${B},0.15)`; } tr.appendChild(td); }
        tr.addEventListener('dblclick', ()=>{ navigator.clipboard.writeText([w.well, w.content||'', ...w.values].join(',')); });
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);

      // sorting
      trh.querySelectorAll('th').forEach(th=>{
        th.style.cursor='pointer';
        th.onclick=()=>{
          const key=th.dataset.key; if(!key) return; const factor = (th.dataset.dir==='desc')? -1:1; th.dataset.dir = (factor===1?'desc':'asc');
          currentRows.sort((a,b)=>{
            if (key==='well') return factor * a.well.localeCompare(b.well);
            if (key==='content') return factor * (''+(a.content||'')).localeCompare(''+(b.content||''));
            if (key && key.startsWith('c')) { const idx=parseInt(key.slice(1),10); return factor * (((b.values[idx]||0)-(a.values[idx]||0))); }
            return 0;
          });
          currentPage=1; renderTable(currentRows);
        };
      });

      pageInfo.textContent = `${start+1}-${end} / ${total}`;
    }
    pageSizeSel.addEventListener('change', ()=>{ currentPage=1; renderTable(currentRows); });
    document.getElementById('prevPage').addEventListener('click', ()=>{ if(currentPage>1){ currentPage--; renderTable(currentRows); } });
    document.getElementById('nextPage').addEventListener('click', ()=>{ const pages=Math.ceil(currentRows.length/parseInt(pageSizeSel.value,10)); if(currentPage<pages){ currentPage++; renderTable(currentRows); } });
    renderTable(DATA.wells);

    // Content chips
    const chipsBox = document.getElementById('chips');
    const contents = Array.from(new Set(DATA.wells.map(w=>w.content || ''))).filter(Boolean).sort();
    let activeChips = new Set();
    contents.forEach(c=>{ const btn=document.createElement('button'); btn.textContent=c; btn.className='btn secondary'; btn.onclick=()=>{ if(activeChips.has(c)) activeChips.delete(c); else activeChips.add(c); btn.classList.toggle('secondary'); applyFilterSort(); }; chipsBox.appendChild(btn); });

    // Theme toggle
    const themeBtn = document.getElementById('themeBtn');
    themeBtn.addEventListener('click', () => { document.body.classList.toggle('dark'); drawHeatmap(wellSelect.value); renderNeighbors(wellSelect.value); });

    // Stats for selected well
    function stats(values) {
      const arr = values.filter(v => v != null && isFinite(v));
      const n = arr.length; if (!n) return { n: 0, min: NaN, max: NaN, mean: NaN, auc: NaN, peakIndex: -1 };
      let min = arr[0], max = arr[0], sum = 0, auc = 0, peakIndex = 0;
      for (let i = 0; i < n; i++) { const v = arr[i]; if (v < min) min = v; if (v > max) { max = v; peakIndex = i; } sum += v; if (i > 0) auc += 0.5 * (arr[i-1] + v); }
      return { n, min, max, mean: sum / n, auc, peakIndex };
    }
    const statsBox = document.getElementById('statsBox');
    function renderStats(wellId) {
      const w = DATA.wells.find(x => x.well === wellId) || DATA.wells[0];
      const s = stats(w.values);
      statsBox.textContent = `n=${s.n}, min=${s.min.toFixed(0)}, max=${s.max.toFixed(0)}, mean=${s.mean.toFixed(0)}, AUC≈${s.auc.toFixed(0)}, peak=${DATA.timeLabels[s.peakIndex]}`;
    }
    renderStats(wellSelect.value);

    // Filtering, sorting, and downloads
    const filterInput = document.getElementById('filterInput');
    const sortSelect = document.getElementById('sortSelect');
    function applyFilterSort() {
      const q = filterInput.value.trim().toLowerCase();
      let rows = DATA.wells.filter(w => (w.well.toLowerCase().includes(q) || (w.content || '').toLowerCase().includes(q)) && (activeChips.size===0 || activeChips.has(w.content||'')) );
      const by = sortSelect.value;
      if (by === 'peak' || by === 'mean') {
        rows = rows.map(w => ({ ...w, _mean: w.values.reduce((a,b) => a + (b || 0), 0) / w.values.filter(v => v!=null).length, _peak: Math.max(...w.values.filter(v => v!=null)) }));
        rows.sort((a,b) => (by==='peak' ? (b._peak - a._peak) : (b._mean - a._mean)));
        rows = rows.map(({_mean,_peak, ...rest}) => rest);
      }
      currentPage=1; renderTable(rows);
    }
    filterInput.addEventListener('input', applyFilterSort);
    sortSelect.addEventListener('change', applyFilterSort);

    function toCSV(rows) {
      const header = ['Well','Content', ...DATA.timeLabels];
      const lines = [header.join(',')];
      for (const w of rows) { const row = [w.well, w.content || '', ...w.values.map(v => v==null? '' : v)]; lines.push(row.join(',')); }
      return lines.join('\n');
    }
    function download(name, text) {
      const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([text], {type:'text/csv'})); a.download = name; a.click(); setTimeout(() => URL.revokeObjectURL(a.href), 0);
    }
    document.getElementById('dlWideBtn').addEventListener('click', () => { download('hoff_wide.csv', toCSV(DATA.wells)); });
    document.getElementById('dlWellBtn').addEventListener('click', () => { const id = wellSelect.value; const w = DATA.wells.find(x => x.well === id); const header = 'Time,FI\n'; const rows = DATA.timeLabels.map((t, i) => `${t},${w.values[i] ?? ''}`).join('\n'); download(`well_${id}.csv`, header + rows); });
    document.getElementById('dlCorrBtn').addEventListener('click', () => { const header = ['Well', ...WELL_IDS]; const lines = [header.join(',')]; for (let i=0;i<N;i++) { lines.push([WELL_IDS[i], ...CORR[i].map(v => v.toFixed(4))].join(',')); } download('hoff_correlations.csv', lines.join('\n')); });

    // ===== Relations (correlations) =====
    let WELL_IDS = DATA.wells.map(w => w.well);
    let WELL_INDEX = Object.fromEntries(WELL_IDS.map((id, i) => [id, i]));

    function pearson(a, b) {
      let n = Math.min(a.length, b.length);
      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0, count = 0;
      for (let i = 0; i < n; i++) {
        const x = a[i];
        const y = b[i];
        if (x == null || y == null || !isFinite(x) || !isFinite(y)) continue;
        sumX += x; sumY += y; sumXY += x*y; sumX2 += x*x; sumY2 += y*y; count++;
      }
      if (count < 2) return 0;
      const num = count * sumXY - sumX * sumY;
      const den = Math.sqrt((count * sumX2 - sumX * sumX) * (count * sumY2 - sumY * sumY));
      if (!isFinite(den) || den === 0) return 0;
      let r = num / den;
      if (r > 1) r = 1; if (r < -1) r = -1;
      return r;
    }

    // Build correlation matrix and top pairs
    const N = DATA.wells.length;
    const CORR = Array.from({ length: N }, () => Array(N).fill(0));
    const pairs = [];
    for (let i = 0; i < N; i++) {
      CORR[i][i] = 1;
      for (let j = i + 1; j < N; j++) {
        const r = pearson(DATA.wells[i].values, DATA.wells[j].values);
        CORR[i][j] = r;
        CORR[j][i] = r;
        pairs.push({ i, j, r });
      }
    }
    pairs.sort((a, b) => b.r - a.r);

    // Populate top pairs table (top 10)
    const topBody = document.querySelector('#topPairsTable tbody');
    topBody.innerHTML = '';
    for (const { i, j, r } of pairs.slice(0, 10)) {
      const tr = document.createElement('tr');
      const tdA = document.createElement('td'); tdA.textContent = WELL_IDS[i]; tr.appendChild(tdA);
      const tdB = document.createElement('td'); tdB.textContent = WELL_IDS[j]; tr.appendChild(tdB);
      const tdR = document.createElement('td'); tdR.textContent = r.toFixed(3); tr.appendChild(tdR);
      topBody.appendChild(tr);
    }

    // Heatmap rendering
    const heat = document.getElementById('corrHeatmap');
    const ctx = heat.getContext('2d');
    function colorForR(r) {
      // r in [-1, 1]: blue (-1) -> white (0) -> red (1)
      r = Math.max(-1, Math.min(1, r));
      if (r >= 0) {
        const g = Math.round(255 * (1 - r));
        const b = Math.round(255 * (1 - r));
        return `rgb(255, ${g}, ${b})`;
      } else {
        const t = 1 + r; // r=-1 -> 0, r=0 -> 1
        const val = Math.round(255 * t);
        return `rgb(${val}, ${val}, 255)`;
      }
    }

    function drawHeatmap(selectedId) {
      const margin = 80;
      const cell = 22;
      const size = margin + N * cell + 10;
      heat.width = size;
      heat.height = size;
      ctx.clearRect(0, 0, size, size);

      // Cells
      for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
          ctx.fillStyle = colorForR(CORR[i][j]);
          ctx.fillRect(margin + j * cell, margin + i * cell, cell, cell);
        }
      }

      // Grid lines
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 0.5;
      for (let k = 0; k <= N; k++) {
        ctx.beginPath();
        ctx.moveTo(margin, margin + k * cell);
        ctx.lineTo(margin + N * cell, margin + k * cell);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(margin + k * cell, margin);
        ctx.lineTo(margin + k * cell, margin + N * cell);
        ctx.stroke();
      }

      // Labels
      ctx.fillStyle = '#333';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i < N; i++) {
        const y = margin + i * cell + cell / 2;
        ctx.fillText(WELL_IDS[i], margin - 8, y);
      }
      ctx.save();
      ctx.translate(margin, margin - 8);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let j = 0; j < N; j++) {
        const x = j * cell + cell / 2;
        ctx.fillText(WELL_IDS[j], 0, x);
      }
      ctx.restore();

      // Highlight selection
      if (selectedId && selectedId in WELL_INDEX) {
        const idx = WELL_INDEX[selectedId];
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        // Row
        ctx.strokeRect(margin, margin + idx * cell, N * cell, cell);
        // Column
        ctx.strokeRect(margin + idx * cell, margin, cell, N * cell);
      }
    }

    // Neighbors list for selected well
    function renderNeighbors(selectedId) {
      const box = document.getElementById('neighborsList');
      box.innerHTML = '';
      if (!(selectedId in WELL_INDEX)) return;
      const i = WELL_INDEX[selectedId];
      const arr = [];
      for (let j = 0; j < N; j++) {
        if (j === i) continue;
        arr.push({ id: WELL_IDS[j], r: CORR[i][j] });
      }
      arr.sort((a, b) => b.r - a.r);
      const top = arr.slice(0, 6).map(x => `${x.id} (r=${x.r.toFixed(3)})`).join('  |  ');
      box.textContent = top;
    }

    // Windowed correlations
    const winStart = document.getElementById('winStart');
    const winEnd = document.getElementById('winEnd');
    const winLabel = document.getElementById('winLabel');
    function recomputeCorr() {
      const s = Math.min(+winStart.value, +winEnd.value); const e = Math.max(+winStart.value, +winEnd.value);
      winLabel.textContent = `${DATA.timeLabels[s]} - ${DATA.timeLabels[e]}`;
      for (let i=0;i<N;i++) for (let j=0;j<N;j++) CORR[i][j]=0;
      pairs.length=0;
      for (let i=0; i<N; i++) {
        CORR[i][i]=1;
        for (let j=i+1;j<N;j++) {
          const a=DATA.wells[i].values.slice(s,e+1); const b=DATA.wells[j].values.slice(s,e+1); const r=pearson(a,b);
          CORR[i][j]=r; CORR[j][i]=r; pairs.push({i,j,r});
        }
      }
      pairs.sort((a,b)=>b.r-a.r);
    }
    winStart.addEventListener('input', ()=>{ recomputeCorr(); drawHeatmap(wellSelect.value); });
    winEnd.addEventListener('input', ()=>{ recomputeCorr(); drawHeatmap(wellSelect.value); });

    // Simple greedy seriation for clustering
    const clusterBtn = document.getElementById('clusterBtn');
    const resetOrderBtn = document.getElementById('resetOrderBtn');
    const ORIGINAL_IDS = DATA.wells.map(w=>w.well);
    function clusterOrder() {
      const used=new Set(); const best = pairs[0]; if(!best) return ORIGINAL_IDS.slice();
      let order=[best.i,best.j]; used.add(best.i); used.add(best.j);
      while(order.length<N){
        let bestAdd=null, bestPos=null, bestR=-Infinity;
        for(let k=0;k<N;k++){ if(used.has(k)) continue; const rLeft=CORR[k][order[0]]; const rRight=CORR[k][order[order.length-1]]; if(rLeft>bestR){ bestR=rLeft; bestAdd=k; bestPos='left'; } if(rRight>bestR){ bestR=rRight; bestAdd=k; bestPos='right'; } }
        if(bestPos==='left') order.unshift(bestAdd); else order.push(bestAdd); used.add(bestAdd);
      }
      return order.map(idx=>DATA.wells[idx].well);
    }
    clusterBtn.addEventListener('click', ()=>{
      const ids = clusterOrder();
      WELL_IDS = ids; WELL_INDEX = Object.fromEntries(WELL_IDS.map((id,i)=>[id,i]));
      drawHeatmap(wellSelect.value);
    });
    resetOrderBtn.addEventListener('click', ()=>{
      WELL_IDS = ORIGINAL_IDS.slice(); WELL_INDEX = Object.fromEntries(WELL_IDS.map((id,i)=>[id,i]));
      drawHeatmap(wellSelect.value);
    });

    // Initial relations render
    recomputeCorr();
    drawHeatmap(wellSelect.value);
    renderNeighbors(wellSelect.value);

    // Update on selection change
    wellSelect.addEventListener('change', (e) => {
      drawHeatmap(e.target.value);
      renderNeighbors(e.target.value);
    });

    // Click on heatmap to select a well (row)
    heat.addEventListener('click', (evt) => {
      const rect = heat.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const margin = 80;
      const cell = 22;
      if (x >= margin && y >= margin) {
        const i = Math.floor((y - margin) / cell);
        if (i >= 0 && i < N) {
          const id = WELL_IDS[i];
          wellSelect.value = id;
          renderChart(id);
          drawHeatmap(id);
          renderNeighbors(id);
        }
      }
    });
  </script>
</body>
</html>
